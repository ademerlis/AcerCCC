GO_IDs <- module_df$GO.ID
GO_child_term <- module_df$Term
# Wrap in GOCollection
collection <- GOCollection(GO_IDs)
# Run GOslim for each ontology
for (ontology in c("BP", "MF", "CC")) {
tmp <- goSlim(GOCollection(module_df$GO.ID), slim, ontology) %>%
rownames_to_column("GO") %>%
mutate(
module = mod,
Ontology = ontology
) %>%
rowwise() %>%
mutate(GOTerms = paste(goWide(GO, GO_IDs, ontology), collapse = ", ")) %>% # adding new column for the GO terms
filter(Count > 0)
all_slim_results[[paste(mod, ontology, sep = "_")]] <- tmp
}
}
# Combine everything into one tibble
all_slim_results <- bind_rows(all_slim_results)
all_slim_results
# Vectorized helper function
goWideVec <- function(GO_IDs, genes, GO_ontology) {
GOTERM <- getAnnMap("TERM", "GO")
terms <- mget(slim_ids, GOTERM, ifnotfound = NA)
terms <- terms[vapply(terms, Ontology, character(1)) == GO_ontology]
slim_ids_o <- names(terms)
if(length(slim_ids_o) == 0) return(character(0))
OFFSPRING <- switch(GO_ontology,
MF = getAnnMap("MFOFFSPRING", "GO"),
BP = getAnnMap("BPOFFSPRING", "GO"),
CC = getAnnMap("CCOFFSPRING", "GO"))
slim_to_gene <- mget(slim_ids_o, OFFSPRING, ifnotfound = NA)
slim_to_gene <- slim_to_gene[!sapply(slim_to_gene, function(x) all(is.na(x)))]
gene_to_slim <- revmap(slim_to_gene)[genes]
gene_to_slim <- gene_to_slim[!sapply(gene_to_slim, is.null)]
# Intersect with slim IDs
result <- lapply(gene_to_slim, function(x) intersect(x, slim_ids_o))
names(result) <- names(gene_to_slim)
# Only keep GO IDs that are in your module
module_go_match <- lapply(result, function(x) intersect(x, GO_IDs))
return(module_go_match)
}
# Function to process one module + ontology
process_module_ontology <- function(module_df, ontology) {
GO_IDs <- module_df$GO.ID
gene_IDs <- module_df$GO.ID  # replace with gene IDs if you have them
goSlim(GOCollection(GO_IDs), slim, ontology) %>%
as.data.frame() %>%
rownames_to_column("GO") %>%
mutate(
module = unique(module_df$module),
Ontology = ontology,
GOTerms = map(GO, ~ paste(unlist(goWideVec(GO_IDs, gene_IDs, ontology)), collapse = ", "))
) %>%
filter(Count > 0)
}
# Main loop with purrr::map
all_slim_results <- GO_results %>%
split(.$module) %>%
map(~ map_dfr(c("BP", "MF", "CC"), ~ process_module_ontology(.x, .y)))
# Combine all modules into a single data frame (safe to write to CSV)
GO_results_df <- bind_rows(GO_results)
GO_results_df
str(GO_results)
# Background universe: all unique genes across all modules
allgenes <- unique(all_genes$gene)
# List of modules to iterate over
modules <- unique(all_genes$module)
# Initialize results container
GO_results <- list()
# Loop through each module
for(mod in modules) {
# Genes in this specific module
module_genes <- all_genes$gene[all_genes$module == mod]
# Build geneList for topGO (0/1 factor)
geneList <- factor(as.integer(allgenes %in% module_genes),
levels = c(0,1))
names(geneList) <- allgenes
#Build the topGOdata matrix for each ontology categories
GOdata_BP <- new("topGOdata", ontology = "BP", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_CC <- new("topGOdata", ontology = "CC", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_MF <- new("topGOdata", ontology = "MF", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO, nodeSize=5)
#Perform enrichment analysis
# run weighted algorithm as classic doesnt take into consideration GO hierarchy so could overrepresent enrichment
resultTopGO.BP <- runTest(GOdata_BP, algorithm = "weight01", statistic = "fisher")
resultTopGO.CC <- runTest(GOdata_CC, algorithm = "weight01", statistic = "fisher" )
resultTopGO.MF <- runTest(GOdata_MF, algorithm = "weight01", statistic = "fisher" )
allBPGO = genesInTerm(GOdata_BP)
allCCGO = genesInTerm(GOdata_CC)
allMFGO = genesInTerm(GOdata_MF)
### Load function for extracting genes associated with a GO ID
BP_ANNOTATION = lapply(allBPGO,function(x) x[x %in% module_genes])
CC_ANNOTATION = lapply(allCCGO,function(x) x[x %in% module_genes])
MF_ANNOTATION = lapply(allMFGO,function(x) x[x %in% module_genes])
#Transform data and save into csv
# Create results tables (numChar parameter controls term description length)
BP_Res <- GenTable(GOdata_BP, weightFisher = resultTopGO.BP, topNodes = length(allBPGO), numChar = 1000)
BP_Res$Ontology <- "BP"
BP_Res$GeneList <- vapply(BP_Res$GO.ID, function(go) {
str_c(BP_ANNOTATION[[go]], collapse = ",")
}, character(1))
CC_Res <- GenTable(GOdata_CC, weightFisher = resultTopGO.CC, topNodes = length(allCCGO), numChar = 1000)
CC_Res$Ontology <- "CC"
CC_Res$GeneList <- vapply(CC_Res$GO.ID, function(go) {
str_c(CC_ANNOTATION[[go]], collapse = ",")
}, character(1))
MF_Res <- GenTable(GOdata_MF, weightFisher = resultTopGO.MF, topNodes = length(allMFGO), numChar = 1000)
MF_Res$Ontology <- "MF"
MF_Res$GeneList <- vapply(MF_Res$GO.ID, function(go) {
str_c(MF_ANNOTATION[[go]], collapse = ",")
}, character(1))
GO_combine <- bind_rows(MF_Res, CC_Res, BP_Res)
GO_combine$weightFisher <- as.numeric(GO_combine$weightFisher)
GO_combine <- GO_combine[GO_combine$weightFisher < 0.01, ]
GO_combine$module <- mod
GO_results[[mod]] <- GO_combine
}
str(GO_results)
# Combine all modules into a single data frame (safe to write to CSV)
GO_results_df <- bind_rows(GO_results)
write_csv(GO_results_df, "4_WGCNA/GO_enrichment_all_modules_allterms.csv")
GO_results
GO_results
# Load the GO Slim file
slim <- getOBOCollection("goslim_generic.obo") #download here (https://release.geneontology.org/2024-09-08/ontology/subsets/index.html#:~:text=281%20KB-,goslim_generic.obo,-117%20KB)
slim_ids <- GSEABase::ids(slim) # gets slim IDs
# Helper function: map slim → detailed terms → genes
goWide <- function(slim, genes, GO_ontology) {
GOTERM <- getAnnMap("TERM", "GO")
terms <- mget(slim_ids, GOTERM, ifnotfound = NA)
terms <- terms[vapply(terms, Ontology, character(1)) == GO_ontology]
slim_ids_o <- names(terms)
OFFSPRING <- switch(GO_ontology,
MF = getAnnMap("MFOFFSPRING", "GO"),
BP = getAnnMap("BPOFFSPRING", "GO"),
CC = getAnnMap("CCOFFSPRING", "GO"),
stop("GO_ontology must be 'MF', 'BP', or 'CC'")
)
slim_to_gene <- mget(slim_ids_o, OFFSPRING, ifnotfound = NA)
slim_to_gene <- slim_to_gene[!is.na(slim_to_gene)]
gene_to_slim <- revmap(slim_to_gene)[genes]
gene_to_slim <- gene_to_slim[!vapply(gene_to_slim, is.null, logical(1))]
if (length(gene_to_slim) == 0) {
return(c())
}
return(names(gene_to_slim)[sapply(gene_to_slim, function(x) any(grepl(slim, unlist(x))))])
}
all_slim_results <- list()
# Loop through modules in GO_results
for (mod in unique(GO_results$module)) {
message("Processing module: ", mod)
# Subset one module’s enriched GO terms
module_df <- GO_results %>% filter(module == mod)
GO_IDs <- module_df$GO.ID
GO_child_term <- module_df$Term
# Wrap in GOCollection
collection <- GOCollection(GO_IDs)
# Run GOslim for each ontology
for (ontology in c("BP", "MF", "CC")) {
tmp <- goSlim(GOCollection(module_df$GO.ID), slim, ontology) %>%
rownames_to_column("GO") %>%
mutate(
module = mod,
Ontology = ontology
) %>%
rowwise() %>%
mutate(GOTerms = paste(goWide(GO, GO_IDs, ontology), collapse = ", ")) %>% # adding new column for the GO terms
filter(Count > 0)
all_slim_results[[paste(mod, ontology, sep = "_")]] <- tmp
}
}
# Combine everything into one tibble
all_slim_results <- bind_rows(all_slim_results)
all_slim_results
message("Processing module: ", mod)
# Loop through modules in GO_results
for (mod in unique(GO_results$module)) {
message("Processing module: ", mod)
# Subset one module’s enriched GO terms
module_df <- GO_results %>% filter(module == mod)
GO_IDs <- module_df$GO.ID
GO_child_term <- module_df$Term
# Wrap in GOCollection
collection <- GOCollection(GO_IDs)
# Run GOslim for each ontology
for (ontology in c("BP", "MF", "CC")) {
tmp <- goSlim(GOCollection(module_df$GO.ID), slim, ontology) %>%
rownames_to_column("GO") %>%
mutate(
module = mod,
Ontology = ontology
) %>%
rowwise() %>%
mutate(GOTerms = paste(goWide(GO, GO_IDs, ontology), collapse = ", ")) %>% # adding new column for the GO terms
filter(Count > 0)
all_slim_results[[paste(mod, ontology, sep = "_")]] <- tmp
}
}
# Helper function: map slim → detailed terms → genes
goWide <- function(slim, genes, GO_ontology) {
GOTERM <- getAnnMap("TERM", "GO")
terms <- mget(slim_ids, GOTERM, ifnotfound = NA)
terms <- terms[vapply(terms, Ontology, character(1)) == GO_ontology]
slim_ids_o <- names(terms)
OFFSPRING <- switch(GO_ontology,
MF = getAnnMap("MFOFFSPRING", "GO"),
BP = getAnnMap("BPOFFSPRING", "GO"),
CC = getAnnMap("CCOFFSPRING", "GO"),
stop("GO_ontology must be 'MF', 'BP', or 'CC'")
)
slim_to_gene <- mget(slim_ids_o, OFFSPRING, ifnotfound = NA)
slim_to_gene <- slim_to_gene[!is.na(slim_to_gene)]
gene_to_slim <- revmap(slim_to_gene)[genes]
gene_to_slim <- gene_to_slim[!vapply(gene_to_slim, is.null, logical(1))]
if (length(gene_to_slim) == 0) {
return(c())
}
return(names(gene_to_slim)[sapply(gene_to_slim, function(x) any(grepl(slim, unlist(x))))])
}
all_slim_results <- list()
# Loop through modules in GO_results
for (mod in unique(GO_results$module)) {
message("Processing module: ", mod)
# Subset one module’s enriched GO terms
module_df <- GO_results %>% filter(module == mod)
GO_IDs <- module_df$GO.ID
GO_child_term <- module_df$Term
# Wrap in GOCollection
collection <- GOCollection(GO_IDs)
# Run GOslim for each ontology
for (ontology in c("BP", "MF", "CC")) {
tmp <- goSlim(GOCollection(module_df$GO.ID), slim, ontology) %>%
rownames_to_column("GO") %>%
mutate(
module = mod,
Ontology = ontology
) %>%
rowwise() %>%
mutate(GOTerms = paste(goWide(GO, GO_IDs, ontology), collapse = ", ")) %>% # adding new column for the GO terms
filter(Count > 0)
all_slim_results[[paste(mod, ontology, sep = "_")]] <- tmp
}
}
GO_results %>% filter(module == mod)
GO_results
GO_results_df %>% filter(module == mod)
# Loop through modules in GO_results
for (mod in unique(GO_results$module)) {
message("Processing module: ", mod)
# Subset one module’s enriched GO terms
module_df <- GO_results_df %>% filter(module == mod)
GO_IDs <- module_df$GO.ID
GO_child_term <- module_df$Term
# Wrap in GOCollection
collection <- GOCollection(GO_IDs)
# Run GOslim for each ontology
for (ontology in c("BP", "MF", "CC")) {
tmp <- goSlim(GOCollection(module_df$GO.ID), slim, ontology) %>%
rownames_to_column("GO") %>%
mutate(
module = mod,
Ontology = ontology
) %>%
rowwise() %>%
mutate(GOTerms = paste(goWide(GO, GO_IDs, ontology), collapse = ", ")) %>% # adding new column for the GO terms
filter(Count > 0)
all_slim_results[[paste(mod, ontology, sep = "_")]] <- tmp
}
}
GO_results_df
# Function: map slim -> detailed GO terms -> genes
goWide <- function(slim, genes, GO_ontology) {
GOTERM <- getAnnMap("TERM", "GO")
terms <- mget(slim_ids, GOTERM, ifnotfound = NA)
terms <- terms[vapply(terms, Ontology, character(1)) == GO_ontology]
slim_ids_o <- names(terms)
OFFSPRING <- switch(GO_ontology,
MF = getAnnMap("MFOFFSPRING", "GO"),
BP = getAnnMap("BPOFFSPRING", "GO"),
CC = getAnnMap("CCOFFSPRING", "GO"))
slim_to_gene <- mget(slim_ids_o, OFFSPRING, ifnotfound = NA)
slim_to_gene <- slim_to_gene[!is.na(slim_to_gene)]
gene_to_slim <- revmap(slim_to_gene)[genes]
gene_to_slim <- gene_to_slim[!vapply(gene_to_slim, is.null, logical(1))]
if (length(gene_to_slim) == 0) return(character())
names(gene_to_slim)[sapply(gene_to_slim, function(x) any(grepl(slim, unlist(x))))]
}
all_slim_results <- list()
for (mod in unique(GO_results_df$module)) {
message("Processing module GOslim: ", mod)
module_df <- GO_results_df %>% filter(module == mod)
for (ontology in c("BP", "MF", "CC")) {
tmp <- goSlim(GOCollection(module_df$GO.ID), slim, ontology) %>%
rownames_to_column("GO") %>%
mutate(module = mod, Ontology = ontology) %>%
rowwise() %>%
mutate(GOTerms = paste(goWide(GO, module_df$GO.ID, ontology), collapse = ", ")) %>%
filter(Count > 0)
all_slim_results[[paste(mod, ontology, sep = "_")]] <- tmp
}
}
# Combine everything into one tibble
all_slim_results <- bind_rows(all_slim_results)
all_slim_results
# Path to your folder containing the CSV files
module_gene_lists_subfolder <- "4_WGCNA/module_gene_lists/significant_modules"
# List all files ending with "_genelist.csv" in the folder
file_list <- list.files(path = module_gene_lists_subfolder,
pattern = "_genelist\\.csv$",
full.names = TRUE)
# Read all files and add a 'module' column with the file name
all_genes <- file_list %>%
set_names() %>%                    # name the list with full paths
map_dfr(~ read_csv(.x) %>%
mutate(module = str_remove(tools::file_path_sans_ext(basename(.x)),
"_genelist$")),
.id = NULL)
# Check result
head(all_genes)
all_genes %>%
dplyr::select(gene, module) -> all_genes
all_genes
# Background universe: all unique genes across all modules
allgenes <- unique(all_genes$gene)
# List of modules to iterate over
modules <- unique(all_genes$module)
# Initialize results container
GO_results <- list()
# Loop through each module
for(mod in modules) {
# Genes in this specific module
module_genes <- all_genes$gene[all_genes$module == mod]
# Build geneList for topGO (0/1 factor)
geneList <- factor(as.integer(allgenes %in% module_genes),
levels = c(0,1))
names(geneList) <- allgenes
#Build the topGOdata matrix for each ontology categories
GOdata_BP <- new("topGOdata", ontology = "BP", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_CC <- new("topGOdata", ontology = "CC", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_MF <- new("topGOdata", ontology = "MF", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO, nodeSize=5)
#Perform enrichment analysis
# run weighted algorithm as classic doesnt take into consideration GO hierarchy so could overrepresent enrichment
resultTopGO.BP <- runTest(GOdata_BP, algorithm = "weight01", statistic = "fisher")
resultTopGO.CC <- runTest(GOdata_CC, algorithm = "weight01", statistic = "fisher" )
resultTopGO.MF <- runTest(GOdata_MF, algorithm = "weight01", statistic = "fisher" )
allBPGO = genesInTerm(GOdata_BP)
allCCGO = genesInTerm(GOdata_CC)
allMFGO = genesInTerm(GOdata_MF)
### Load function for extracting genes associated with a GO ID
BP_ANNOTATION = lapply(allBPGO,function(x) x[x %in% module_genes])
CC_ANNOTATION = lapply(allCCGO,function(x) x[x %in% module_genes])
MF_ANNOTATION = lapply(allMFGO,function(x) x[x %in% module_genes])
#Transform data and save into csv
# Create results tables (numChar parameter controls term description length)
BP_Res <- GenTable(GOdata_BP, weightFisher = resultTopGO.BP, topNodes = length(allBPGO), numChar = 1000)
BP_Res$Ontology <- "BP"
BP_Res$GeneList <- vapply(BP_Res$GO.ID, function(go) {
genes <- BP_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
CC_Res <- GenTable(GOdata_CC, weightFisher = resultTopGO.CC, topNodes = length(allCCGO), numChar = 1000)
CC_Res$Ontology <- "CC"
CC_Res$GeneList <- vapply(CC_Res$GO.ID, function(go) {
genes <- CC_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
MF_Res <- GenTable(GOdata_MF, weightFisher = resultTopGO.MF, topNodes = length(allMFGO), numChar = 1000)
MF_Res$Ontology <- "MF"
MF_Res$GeneList <- vapply(MF_Res$GO.ID, function(go) {
genes <- MF_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
GO_combine <- bind_rows(MF_Res, CC_Res, BP_Res)
GO_combine$weightFisher <- as.numeric(GO_combine$weightFisher)
GO_combine <- GO_combine[GO_combine$weightFisher < 0.01, ]
GO_combine$module <- mod
GO_results[[mod]] <- GO_combine
}
str(GO_results)
GO_results
# Loop through each module
for(mod in modules) {
# Genes in this specific module
module_genes <- all_genes$gene[all_genes$module == mod]
# Build geneList for topGO (0/1 factor)
geneList <- factor(as.integer(allgenes %in% module_genes),
levels = c(0,1))
names(geneList) <- allgenes
#Build the topGOdata matrix for each ontology categories
GOdata_BP <- new("topGOdata", ontology = "BP", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_CC <- new("topGOdata", ontology = "CC", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_MF <- new("topGOdata", ontology = "MF", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO, nodeSize=5)
#Perform enrichment analysis
# run weighted algorithm as classic doesnt take into consideration GO hierarchy so could overrepresent enrichment
resultTopGO.BP <- runTest(GOdata_BP, algorithm = "weight01", statistic = "fisher")
resultTopGO.CC <- runTest(GOdata_CC, algorithm = "weight01", statistic = "fisher" )
resultTopGO.MF <- runTest(GOdata_MF, algorithm = "weight01", statistic = "fisher" )
allBPGO = genesInTerm(GOdata_BP)
allCCGO = genesInTerm(GOdata_CC)
allMFGO = genesInTerm(GOdata_MF)
### Load function for extracting genes associated with a GO ID
BP_ANNOTATION = lapply(allBPGO,function(x) x[x %in% module_genes])
CC_ANNOTATION = lapply(allCCGO,function(x) x[x %in% module_genes])
MF_ANNOTATION = lapply(allMFGO,function(x) x[x %in% module_genes])
#Transform data and save into csv
# Create results tables (numChar parameter controls term description length)
BP_Res <- GenTable(GOdata_BP, weightFisher = resultTopGO.BP, topNodes = length(allBPGO), numChar = 1000)
BP_Res$Ontology <- "BP"
BP_Res$GeneList <- vapply(BP_Res$GO.ID, function(go) {
genes <- BP_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
CC_Res <- GenTable(GOdata_CC, weightFisher = resultTopGO.CC, topNodes = length(allCCGO), numChar = 1000)
CC_Res$Ontology <- "CC"
CC_Res$GeneList <- vapply(CC_Res$GO.ID, function(go) {
genes <- CC_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
MF_Res <- GenTable(GOdata_MF, weightFisher = resultTopGO.MF, topNodes = length(allMFGO), numChar = 1000)
MF_Res$Ontology <- "MF"
MF_Res$GeneList <- vapply(MF_Res$GO.ID, function(go) {
genes <- MF_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
GO_combine <- bind_rows(MF_Res, CC_Res, BP_Res) %>%
mutate(weightFisher = as.numeric(weightFisher)) %>%
filter(weightFisher < 0.01) %>%
{ if(nrow(.) > 0) mutate(., module = mod) else . }
}
str(GO_results)
GO_results
modules
# Background universe: all unique genes across all modules
allgenes <- unique(all_genes$gene)
# Initialize results container
GO_results <- list()
# Loop through each module
for(mod in modules) {
# Genes in this specific module
module_genes <- all_genes$gene[all_genes$module == mod]
# Build geneList for topGO (0/1 factor)
geneList <- factor(as.integer(allgenes %in% module_genes),
levels = c(0,1))
names(geneList) <- allgenes
#Build the topGOdata matrix for each ontology categories
GOdata_BP <- new("topGOdata", ontology = "BP", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_CC <- new("topGOdata", ontology = "CC", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO,nodeSize=5)
GOdata_MF <- new("topGOdata", ontology = "MF", allGenes = geneList,
annot = annFUN.gene2GO, gene2GO = geneID2GO, nodeSize=5)
#Perform enrichment analysis
# run weighted algorithm as classic doesnt take into consideration GO hierarchy so could overrepresent enrichment
resultTopGO.BP <- runTest(GOdata_BP, algorithm = "weight01", statistic = "fisher")
resultTopGO.CC <- runTest(GOdata_CC, algorithm = "weight01", statistic = "fisher" )
resultTopGO.MF <- runTest(GOdata_MF, algorithm = "weight01", statistic = "fisher" )
allBPGO = genesInTerm(GOdata_BP)
allCCGO = genesInTerm(GOdata_CC)
allMFGO = genesInTerm(GOdata_MF)
### Load function for extracting genes associated with a GO ID
BP_ANNOTATION = lapply(allBPGO,function(x) x[x %in% module_genes])
CC_ANNOTATION = lapply(allCCGO,function(x) x[x %in% module_genes])
MF_ANNOTATION = lapply(allMFGO,function(x) x[x %in% module_genes])
#Transform data and save into csv
# Create results tables (numChar parameter controls term description length)
BP_Res <- GenTable(GOdata_BP, weightFisher = resultTopGO.BP, topNodes = length(allBPGO), numChar = 1000)
BP_Res$Ontology <- "BP"
BP_Res$GeneList <- vapply(BP_Res$GO.ID, function(go) {
genes <- BP_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
CC_Res <- GenTable(GOdata_CC, weightFisher = resultTopGO.CC, topNodes = length(allCCGO), numChar = 1000)
CC_Res$Ontology <- "CC"
CC_Res$GeneList <- vapply(CC_Res$GO.ID, function(go) {
genes <- CC_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
MF_Res <- GenTable(GOdata_MF, weightFisher = resultTopGO.MF, topNodes = length(allMFGO), numChar = 1000)
MF_Res$Ontology <- "MF"
MF_Res$GeneList <- vapply(MF_Res$GO.ID, function(go) {
genes <- MF_ANNOTATION[[go]]
if(is.null(genes) || length(genes) == 0) return("")
str_c(as.character(genes), collapse = ",")
}, character(1))
GO_combine <- bind_rows(MF_Res, CC_Res, BP_Res) %>%
mutate(weightFisher = as.numeric(weightFisher)) %>%
filter(weightFisher < 0.01) %>%
{ if(nrow(.) > 0) mutate(., module = mod) else . }
}
# Combine all modules into a single data frame (safe to write to CSV)
GO_results_df <- bind_rows(GO_results)
GO_results_df
str(GO_results)
GO_results
